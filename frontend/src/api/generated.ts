/**
 * Generated by orval v7.5.0 ðŸº
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { customAxios } from './mutator';
export type AIMessageInputContentAnyOfItemAnyOf = { [key: string]: unknown };

export type AIMessageInputContentAnyOfItem = string | AIMessageInputContentAnyOfItemAnyOf;

export type AIMessageInputContent = string | AIMessageInputContentAnyOfItem[];

export type AIMessageInputAdditionalKwargs = { [key: string]: unknown };

export type AIMessageInputResponseMetadata = { [key: string]: unknown };

export type AIMessageInputName = string | null;

export type AIMessageInputId = string | null;

export type AIMessageInputUsageMetadata = UsageMetadata | null;

/**
 * Message from an AI.

AIMessage is returned from a chat model as a response to a prompt.

This message represents the output of the model and consists of both
the raw output as returned by the model together standardized fields
(e.g., tool calls, usage metadata) added by the LangChain framework.
 */
export interface AIMessageInput {
  content: AIMessageInputContent;
  additional_kwargs?: AIMessageInputAdditionalKwargs;
  response_metadata?: AIMessageInputResponseMetadata;
  type?: 'ai';
  name?: AIMessageInputName;
  id?: AIMessageInputId;
  example?: boolean;
  tool_calls?: ToolCall[];
  invalid_tool_calls?: InvalidToolCall[];
  usage_metadata?: AIMessageInputUsageMetadata;
  [key: string]: unknown;
 }

export type AIMessageOutputContentAnyOfItemAnyOf = { [key: string]: unknown };

export type AIMessageOutputContentAnyOfItem = string | AIMessageOutputContentAnyOfItemAnyOf;

export type AIMessageOutputContent = string | AIMessageOutputContentAnyOfItem[];

export type AIMessageOutputAdditionalKwargs = { [key: string]: unknown };

export type AIMessageOutputResponseMetadata = { [key: string]: unknown };

export type AIMessageOutputName = string | null;

export type AIMessageOutputId = string | null;

export type AIMessageOutputUsageMetadata = UsageMetadata | null;

/**
 * Message from an AI.

AIMessage is returned from a chat model as a response to a prompt.

This message represents the output of the model and consists of both
the raw output as returned by the model together standardized fields
(e.g., tool calls, usage metadata) added by the LangChain framework.
 */
export interface AIMessageOutput {
  content: AIMessageOutputContent;
  additional_kwargs?: AIMessageOutputAdditionalKwargs;
  response_metadata?: AIMessageOutputResponseMetadata;
  type?: 'ai';
  name?: AIMessageOutputName;
  id?: AIMessageOutputId;
  example?: boolean;
  tool_calls?: ToolCall[];
  invalid_tool_calls?: InvalidToolCall[];
  usage_metadata?: AIMessageOutputUsageMetadata;
  [key: string]: unknown;
 }

export type AIMessageChunkInputContentAnyOfItemAnyOf = { [key: string]: unknown };

export type AIMessageChunkInputContentAnyOfItem = string | AIMessageChunkInputContentAnyOfItemAnyOf;

export type AIMessageChunkInputContent = string | AIMessageChunkInputContentAnyOfItem[];

export type AIMessageChunkInputAdditionalKwargs = { [key: string]: unknown };

export type AIMessageChunkInputResponseMetadata = { [key: string]: unknown };

export type AIMessageChunkInputName = string | null;

export type AIMessageChunkInputId = string | null;

export type AIMessageChunkInputUsageMetadata = UsageMetadata | null;

/**
 * Message chunk from an AI.
 */
export interface AIMessageChunkInput {
  content: AIMessageChunkInputContent;
  additional_kwargs?: AIMessageChunkInputAdditionalKwargs;
  response_metadata?: AIMessageChunkInputResponseMetadata;
  type?: 'AIMessageChunk';
  name?: AIMessageChunkInputName;
  id?: AIMessageChunkInputId;
  example?: boolean;
  tool_calls?: ToolCall[];
  invalid_tool_calls?: InvalidToolCall[];
  usage_metadata?: AIMessageChunkInputUsageMetadata;
  tool_call_chunks?: ToolCallChunk[];
  [key: string]: unknown;
 }

export type AIMessageChunkOutputContentAnyOfItemAnyOf = { [key: string]: unknown };

export type AIMessageChunkOutputContentAnyOfItem = string | AIMessageChunkOutputContentAnyOfItemAnyOf;

export type AIMessageChunkOutputContent = string | AIMessageChunkOutputContentAnyOfItem[];

export type AIMessageChunkOutputAdditionalKwargs = { [key: string]: unknown };

export type AIMessageChunkOutputResponseMetadata = { [key: string]: unknown };

export type AIMessageChunkOutputName = string | null;

export type AIMessageChunkOutputId = string | null;

export type AIMessageChunkOutputUsageMetadata = UsageMetadata | null;

/**
 * Message chunk from an AI.
 */
export interface AIMessageChunkOutput {
  content: AIMessageChunkOutputContent;
  additional_kwargs?: AIMessageChunkOutputAdditionalKwargs;
  response_metadata?: AIMessageChunkOutputResponseMetadata;
  type?: 'AIMessageChunk';
  name?: AIMessageChunkOutputName;
  id?: AIMessageChunkOutputId;
  example?: boolean;
  tool_calls?: ToolCall[];
  invalid_tool_calls?: InvalidToolCall[];
  usage_metadata?: AIMessageChunkOutputUsageMetadata;
  tool_call_chunks?: ToolCallChunk[];
  [key: string]: unknown;
 }

/**
 * Represents response metadata used for batches of input/output LangServe
responses.
 */
export interface BatchResponseMetadata {
  responses: InvokeResponseMetadata[];
  run_ids: string[];
}

export type ChatMessageContentAnyOfItemAnyOf = { [key: string]: unknown };

export type ChatMessageContentAnyOfItem = string | ChatMessageContentAnyOfItemAnyOf;

export type ChatMessageContent = string | ChatMessageContentAnyOfItem[];

export type ChatMessageAdditionalKwargs = { [key: string]: unknown };

export type ChatMessageResponseMetadata = { [key: string]: unknown };

export type ChatMessageName = string | null;

export type ChatMessageId = string | null;

/**
 * Message that can be assigned an arbitrary speaker (i.e. role).
 */
export interface ChatMessage {
  content: ChatMessageContent;
  additional_kwargs?: ChatMessageAdditionalKwargs;
  response_metadata?: ChatMessageResponseMetadata;
  type?: 'chat';
  name?: ChatMessageName;
  id?: ChatMessageId;
  role: string;
  [key: string]: unknown;
 }

export type ChatMessageChunkContentAnyOfItemAnyOf = { [key: string]: unknown };

export type ChatMessageChunkContentAnyOfItem = string | ChatMessageChunkContentAnyOfItemAnyOf;

export type ChatMessageChunkContent = string | ChatMessageChunkContentAnyOfItem[];

export type ChatMessageChunkAdditionalKwargs = { [key: string]: unknown };

export type ChatMessageChunkResponseMetadata = { [key: string]: unknown };

export type ChatMessageChunkName = string | null;

export type ChatMessageChunkId = string | null;

/**
 * Chat Message chunk.
 */
export interface ChatMessageChunk {
  content: ChatMessageChunkContent;
  additional_kwargs?: ChatMessageChunkAdditionalKwargs;
  response_metadata?: ChatMessageChunkResponseMetadata;
  type?: 'ChatMessageChunk';
  name?: ChatMessageChunkName;
  id?: ChatMessageChunkId;
  role: string;
  [key: string]: unknown;
 }

export type ChatOpenAIInputAnyOfItem = AIMessageInput | HumanMessage | ChatMessage | SystemMessage | FunctionMessage | ToolMessage | AIMessageChunkInput | HumanMessageChunk | ChatMessageChunk | SystemMessageChunk | FunctionMessageChunk | ToolMessageChunk;

export type ChatOpenAIInput = string | StringPromptValue | ChatPromptValueConcrete | ChatOpenAIInputAnyOfItem[];

export type ChatOpenAIOutput = AIMessageOutput | HumanMessage | ChatMessage | SystemMessage | FunctionMessage | ToolMessage | AIMessageChunkOutput | HumanMessageChunk | ChatMessageChunk | SystemMessageChunk | FunctionMessageChunk | ToolMessageChunk;

export type ChatPromptValueConcreteMessagesItem = AIMessageInput | HumanMessage | ChatMessage | SystemMessage | FunctionMessage | ToolMessage | AIMessageChunkInput | HumanMessageChunk | ChatMessageChunk | SystemMessageChunk | FunctionMessageChunk | ToolMessageChunk;

/**
 * Chat prompt value which explicitly lists out the message types it accepts.
For use in external schemas.
 */
export interface ChatPromptValueConcrete {
  messages: ChatPromptValueConcreteMessagesItem[];
  type?: 'ChatPromptValueConcrete';
}

export type FeedbackCreateRequestTokenBasedTokenOrUrl = string | string;

export type FeedbackCreateRequestTokenBasedScore = number | number | boolean | null;

export type FeedbackCreateRequestTokenBasedValueAnyOf = { [key: string]: unknown };

export type FeedbackCreateRequestTokenBasedValue = number | number | boolean | string | FeedbackCreateRequestTokenBasedValueAnyOf | null;

export type FeedbackCreateRequestTokenBasedComment = string | null;

export type FeedbackCreateRequestTokenBasedCorrectionAnyOf = { [key: string]: unknown };

export type FeedbackCreateRequestTokenBasedCorrection = FeedbackCreateRequestTokenBasedCorrectionAnyOf | null;

export type FeedbackCreateRequestTokenBasedMetadataAnyOf = { [key: string]: unknown };

export type FeedbackCreateRequestTokenBasedMetadata = FeedbackCreateRequestTokenBasedMetadataAnyOf | null;

/**
 * Shared information between create requests of feedback and feedback objects.
 */
export interface FeedbackCreateRequestTokenBased {
  token_or_url: FeedbackCreateRequestTokenBasedTokenOrUrl;
  score?: FeedbackCreateRequestTokenBasedScore;
  value?: FeedbackCreateRequestTokenBasedValue;
  comment?: FeedbackCreateRequestTokenBasedComment;
  correction?: FeedbackCreateRequestTokenBasedCorrection;
  metadata?: FeedbackCreateRequestTokenBasedMetadata;
}

export type FeedbackTokenTokenUrl = string | null;

export type FeedbackTokenExpiresAt = string | null;

/**
 * Represents the feedback tokens for a given request.
 */
export interface FeedbackToken {
  key: string;
  token_url?: FeedbackTokenTokenUrl;
  expires_at?: FeedbackTokenExpiresAt;
}

export type FunctionMessageContentAnyOfItemAnyOf = { [key: string]: unknown };

export type FunctionMessageContentAnyOfItem = string | FunctionMessageContentAnyOfItemAnyOf;

export type FunctionMessageContent = string | FunctionMessageContentAnyOfItem[];

export type FunctionMessageAdditionalKwargs = { [key: string]: unknown };

export type FunctionMessageResponseMetadata = { [key: string]: unknown };

export type FunctionMessageId = string | null;

/**
 * Message for passing the result of executing a tool back to a model.

FunctionMessage are an older version of the ToolMessage schema, and
do not contain the tool_call_id field.

The tool_call_id field is used to associate the tool call request with the
tool call response. This is useful in situations where a chat model is able
to request multiple tool calls in parallel.
 */
export interface FunctionMessage {
  content: FunctionMessageContent;
  additional_kwargs?: FunctionMessageAdditionalKwargs;
  response_metadata?: FunctionMessageResponseMetadata;
  type?: 'function';
  name: string;
  id?: FunctionMessageId;
  [key: string]: unknown;
 }

export type FunctionMessageChunkContentAnyOfItemAnyOf = { [key: string]: unknown };

export type FunctionMessageChunkContentAnyOfItem = string | FunctionMessageChunkContentAnyOfItemAnyOf;

export type FunctionMessageChunkContent = string | FunctionMessageChunkContentAnyOfItem[];

export type FunctionMessageChunkAdditionalKwargs = { [key: string]: unknown };

export type FunctionMessageChunkResponseMetadata = { [key: string]: unknown };

export type FunctionMessageChunkId = string | null;

/**
 * Function Message chunk.
 */
export interface FunctionMessageChunk {
  content: FunctionMessageChunkContent;
  additional_kwargs?: FunctionMessageChunkAdditionalKwargs;
  response_metadata?: FunctionMessageChunkResponseMetadata;
  type?: 'FunctionMessageChunk';
  name: string;
  id?: FunctionMessageChunkId;
  [key: string]: unknown;
 }

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type HumanMessageContentAnyOfItemAnyOf = { [key: string]: unknown };

export type HumanMessageContentAnyOfItem = string | HumanMessageContentAnyOfItemAnyOf;

export type HumanMessageContent = string | HumanMessageContentAnyOfItem[];

export type HumanMessageAdditionalKwargs = { [key: string]: unknown };

export type HumanMessageResponseMetadata = { [key: string]: unknown };

export type HumanMessageName = string | null;

export type HumanMessageId = string | null;

/**
 * Message from a human.

HumanMessages are messages that are passed in from a human to the model.

Example:

    .. code-block:: python

        from langchain_core.messages import HumanMessage, SystemMessage

        messages = [
            SystemMessage(
                content="You are a helpful assistant! Your name is Bob."
            ),
            HumanMessage(
                content="What is your name?"
            )
        ]

        # Instantiate a chat model and invoke it with the messages
        model = ...
        print(model.invoke(messages))
 */
export interface HumanMessage {
  content: HumanMessageContent;
  additional_kwargs?: HumanMessageAdditionalKwargs;
  response_metadata?: HumanMessageResponseMetadata;
  type?: 'human';
  name?: HumanMessageName;
  id?: HumanMessageId;
  example?: boolean;
  [key: string]: unknown;
 }

export type HumanMessageChunkContentAnyOfItemAnyOf = { [key: string]: unknown };

export type HumanMessageChunkContentAnyOfItem = string | HumanMessageChunkContentAnyOfItemAnyOf;

export type HumanMessageChunkContent = string | HumanMessageChunkContentAnyOfItem[];

export type HumanMessageChunkAdditionalKwargs = { [key: string]: unknown };

export type HumanMessageChunkResponseMetadata = { [key: string]: unknown };

export type HumanMessageChunkName = string | null;

export type HumanMessageChunkId = string | null;

/**
 * Human Message chunk.
 */
export interface HumanMessageChunk {
  content: HumanMessageChunkContent;
  additional_kwargs?: HumanMessageChunkAdditionalKwargs;
  response_metadata?: HumanMessageChunkResponseMetadata;
  type?: 'HumanMessageChunk';
  name?: HumanMessageChunkName;
  id?: HumanMessageChunkId;
  example?: boolean;
  [key: string]: unknown;
 }

/**
 * Breakdown of input token counts.

Does *not* need to sum to full input token count. Does *not* need to have all keys.

Example:

    .. code-block:: python

        {
            "audio": 10,
            "cache_creation": 200,
            "cache_read": 100,
        }

.. versionadded:: 0.3.9
 */
export interface InputTokenDetails {
  audio?: number;
  cache_creation?: number;
  cache_read?: number;
}

export type InvalidToolCallName = string | null;

export type InvalidToolCallArgs = string | null;

export type InvalidToolCallId = string | null;

export type InvalidToolCallError = string | null;

/**
 * Allowance for errors made by LLM.

Here we add an `error` key to surface errors made during generation
(e.g., invalid JSON arguments.)
 */
export interface InvalidToolCall {
  name: InvalidToolCallName;
  args: InvalidToolCallArgs;
  id: InvalidToolCallId;
  error: InvalidToolCallError;
  type?: 'invalid_tool_call';
}

/**
 * Represents response metadata used for just single input/output LangServe
responses.
 */
export interface InvokeResponseMetadata {
  run_id: string;
  /** Feedback tokens from the given run.These tokens allow a user to provide feedback on the run.Only available if server was configured to provide feedback tokens. */
  feedback_tokens: FeedbackToken[];
}

/**
 * Breakdown of output token counts.

Does *not* need to sum to full output token count. Does *not* need to have all keys.

Example:

    .. code-block:: python

        {
            "audio": 10,
            "reasoning": 200,
        }

.. versionadded:: 0.3.9
 */
export interface OutputTokenDetails {
  audio?: number;
  reasoning?: number;
}

/**
 * String prompt value.
 */
export interface StringPromptValue {
  text: string;
  type?: 'StringPromptValue';
}

export type SystemMessageContentAnyOfItemAnyOf = { [key: string]: unknown };

export type SystemMessageContentAnyOfItem = string | SystemMessageContentAnyOfItemAnyOf;

export type SystemMessageContent = string | SystemMessageContentAnyOfItem[];

export type SystemMessageAdditionalKwargs = { [key: string]: unknown };

export type SystemMessageResponseMetadata = { [key: string]: unknown };

export type SystemMessageName = string | null;

export type SystemMessageId = string | null;

/**
 * Message for priming AI behavior.

The system message is usually passed in as the first of a sequence
of input messages.

Example:

    .. code-block:: python

        from langchain_core.messages import HumanMessage, SystemMessage

        messages = [
            SystemMessage(
                content="You are a helpful assistant! Your name is Bob."
            ),
            HumanMessage(
                content="What is your name?"
            )
        ]

        # Define a chat model and invoke it with the messages
        print(model.invoke(messages))
 */
export interface SystemMessage {
  content: SystemMessageContent;
  additional_kwargs?: SystemMessageAdditionalKwargs;
  response_metadata?: SystemMessageResponseMetadata;
  type?: 'system';
  name?: SystemMessageName;
  id?: SystemMessageId;
  [key: string]: unknown;
 }

export type SystemMessageChunkContentAnyOfItemAnyOf = { [key: string]: unknown };

export type SystemMessageChunkContentAnyOfItem = string | SystemMessageChunkContentAnyOfItemAnyOf;

export type SystemMessageChunkContent = string | SystemMessageChunkContentAnyOfItem[];

export type SystemMessageChunkAdditionalKwargs = { [key: string]: unknown };

export type SystemMessageChunkResponseMetadata = { [key: string]: unknown };

export type SystemMessageChunkName = string | null;

export type SystemMessageChunkId = string | null;

/**
 * System Message chunk.
 */
export interface SystemMessageChunk {
  content: SystemMessageChunkContent;
  additional_kwargs?: SystemMessageChunkAdditionalKwargs;
  response_metadata?: SystemMessageChunkResponseMetadata;
  type?: 'SystemMessageChunk';
  name?: SystemMessageChunkName;
  id?: SystemMessageChunkId;
  [key: string]: unknown;
 }

export type ToolCallArgs = { [key: string]: unknown };

export type ToolCallId = string | null;

/**
 * Represents a request to call a tool.

Example:

    .. code-block:: python

        {
            "name": "foo",
            "args": {"a": 1},
            "id": "123"
        }

    This represents a request to call the tool named "foo" with arguments {"a": 1}
    and an identifier of "123".
 */
export interface ToolCall {
  name: string;
  args: ToolCallArgs;
  id: ToolCallId;
  type?: 'tool_call';
}

export type ToolCallChunkName = string | null;

export type ToolCallChunkArgs = string | null;

export type ToolCallChunkId = string | null;

export type ToolCallChunkIndex = number | null;

/**
 * A chunk of a tool call (e.g., as part of a stream).

When merging ToolCallChunks (e.g., via AIMessageChunk.__add__),
all string attributes are concatenated. Chunks are only merged if their
values of `index` are equal and not None.

Example:

.. code-block:: python

    left_chunks = [ToolCallChunk(name="foo", args='{"a":', index=0)]
    right_chunks = [ToolCallChunk(name=None, args='1}', index=0)]

    (
        AIMessageChunk(content="", tool_call_chunks=left_chunks)
        + AIMessageChunk(content="", tool_call_chunks=right_chunks)
    ).tool_call_chunks == [ToolCallChunk(name='foo', args='{"a":1}', index=0)]
 */
export interface ToolCallChunk {
  name: ToolCallChunkName;
  args: ToolCallChunkArgs;
  id: ToolCallChunkId;
  index: ToolCallChunkIndex;
  type?: 'tool_call_chunk';
}

export type ToolMessageContentAnyOfItemAnyOf = { [key: string]: unknown };

export type ToolMessageContentAnyOfItem = string | ToolMessageContentAnyOfItemAnyOf;

export type ToolMessageContent = string | ToolMessageContentAnyOfItem[];

export type ToolMessageAdditionalKwargs = { [key: string]: unknown };

export type ToolMessageResponseMetadata = { [key: string]: unknown };

export type ToolMessageName = string | null;

export type ToolMessageId = string | null;

export type ToolMessageStatus = typeof ToolMessageStatus[keyof typeof ToolMessageStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolMessageStatus = {
  success: 'success',
  error: 'error',
} as const;

/**
 * Message for passing the result of executing a tool back to a model.

ToolMessages contain the result of a tool invocation. Typically, the result
is encoded inside the `content` field.

Example: A ToolMessage representing a result of 42 from a tool call with id

    .. code-block:: python

        from langchain_core.messages import ToolMessage

        ToolMessage(content='42', tool_call_id='call_Jja7J89XsjrOLA5r!MEOW!SL')


Example: A ToolMessage where only part of the tool output is sent to the model
    and the full output is passed in to artifact.

    .. versionadded:: 0.2.17

    .. code-block:: python

        from langchain_core.messages import ToolMessage

        tool_output = {
            "stdout": "From the graph we can see that the correlation between x and y is ...",
            "stderr": None,
            "artifacts": {"type": "image", "base64_data": "/9j/4gIcSU..."},
        }

        ToolMessage(
            content=tool_output["stdout"],
            artifact=tool_output,
            tool_call_id='call_Jja7J89XsjrOLA5r!MEOW!SL',
        )

The tool_call_id field is used to associate the tool call request with the
tool call response. This is useful in situations where a chat model is able
to request multiple tool calls in parallel.
 */
export interface ToolMessage {
  content: ToolMessageContent;
  additional_kwargs?: ToolMessageAdditionalKwargs;
  response_metadata?: ToolMessageResponseMetadata;
  type?: 'tool';
  name?: ToolMessageName;
  id?: ToolMessageId;
  tool_call_id: string;
  artifact?: unknown;
  status?: ToolMessageStatus;
  [key: string]: unknown;
 }

export type ToolMessageChunkContentAnyOfItemAnyOf = { [key: string]: unknown };

export type ToolMessageChunkContentAnyOfItem = string | ToolMessageChunkContentAnyOfItemAnyOf;

export type ToolMessageChunkContent = string | ToolMessageChunkContentAnyOfItem[];

export type ToolMessageChunkAdditionalKwargs = { [key: string]: unknown };

export type ToolMessageChunkResponseMetadata = { [key: string]: unknown };

export type ToolMessageChunkName = string | null;

export type ToolMessageChunkId = string | null;

export type ToolMessageChunkStatus = typeof ToolMessageChunkStatus[keyof typeof ToolMessageChunkStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ToolMessageChunkStatus = {
  success: 'success',
  error: 'error',
} as const;

/**
 * Tool Message chunk.
 */
export interface ToolMessageChunk {
  content: ToolMessageChunkContent;
  additional_kwargs?: ToolMessageChunkAdditionalKwargs;
  response_metadata?: ToolMessageChunkResponseMetadata;
  type?: 'ToolMessageChunk';
  name?: ToolMessageChunkName;
  id?: ToolMessageChunkId;
  tool_call_id: string;
  artifact?: unknown;
  status?: ToolMessageChunkStatus;
  [key: string]: unknown;
 }

/**
 * Usage metadata for a message, such as token counts.

This is a standard representation of token usage that is consistent across models.

Example:

    .. code-block:: python

        {
            "input_tokens": 350,
            "output_tokens": 240,
            "total_tokens": 590,
            "input_token_details": {
                "audio": 10,
                "cache_creation": 200,
                "cache_read": 100,
            },
            "output_token_details": {
                "audio": 10,
                "reasoning": 200,
            }
        }

.. versionchanged:: 0.3.9

    Added ``input_token_details`` and ``output_token_details``.
 */
export interface UsageMetadata {
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
  input_token_details?: InputTokenDetails;
  output_token_details?: OutputTokenDetails;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * Subset of RunnableConfig object in LangChain. Either specify one config for all inputs or a list of configs with one per input. Useful for passing information like tags, metadata etc.
 */
export type ChatBatchRequestConfig = ChatChatOpenAIConfig | ChatChatOpenAIConfig[];

/**
 * Keyword arguments to the runnable. Currently ignored.
 */
export type ChatBatchRequestKwargs = { [key: string]: unknown };

export interface ChatBatchRequest {
  inputs: ChatOpenAIInput[];
  /** Subset of RunnableConfig object in LangChain. Either specify one config for all inputs or a list of configs with one per input. Useful for passing information like tags, metadata etc. */
  config?: ChatBatchRequestConfig;
  /** Keyword arguments to the runnable. Currently ignored. */
  kwargs?: ChatBatchRequestKwargs;
}

export interface ChatBatchResponse {
  /** The outputs corresponding to the inputs the batch request. */
  output: ChatOpenAIOutput[];
  /** Metadata about the response that may be useful to specific clients */
  metadata: BatchResponseMetadata;
}

export interface ChatChatOpenAIConfig { [key: string]: unknown }

/**
 * Keyword arguments to the runnable. Currently ignored.
 */
export type ChatInvokeRequestKwargs = { [key: string]: unknown };

export interface ChatInvokeRequest {
  /** The input to the runnable. */
  input: ChatOpenAIInput;
  /** Subset of RunnableConfig object in LangChain. Useful for passing information like tags, metadata etc. */
  config?: ChatChatOpenAIConfig;
  /** Keyword arguments to the runnable. Currently ignored. */
  kwargs?: ChatInvokeRequestKwargs;
}

export interface ChatInvokeResponse {
  /** The output of the invocation. */
  output: ChatOpenAIOutput;
  /** Metadata about the response that may be useful to specific clients */
  metadata: InvokeResponseMetadata;
}

/**
 * If specified, filter to runnables with matching names
 */
export type ChatStreamEventsRequestIncludeNames = string[] | null;

/**
 * If specified, filter to runnables with matching types
 */
export type ChatStreamEventsRequestIncludeTypes = string[] | null;

/**
 * If specified, filter to runnables with matching tags
 */
export type ChatStreamEventsRequestIncludeTags = string[] | null;

/**
 * If specified, exclude runnables with matching names
 */
export type ChatStreamEventsRequestExcludeNames = string[] | null;

/**
 * If specified, exclude runnables with matching types
 */
export type ChatStreamEventsRequestExcludeTypes = string[] | null;

/**
 * If specified, exclude runnables with matching tags
 */
export type ChatStreamEventsRequestExcludeTags = string[] | null;

export type ChatStreamEventsRequestKwargs = { [key: string]: unknown };

export interface ChatStreamEventsRequest {
  input: ChatOpenAIInput;
  config?: ChatChatOpenAIConfig;
  /** If specified, filter to runnables with matching names */
  include_names?: ChatStreamEventsRequestIncludeNames;
  /** If specified, filter to runnables with matching types */
  include_types?: ChatStreamEventsRequestIncludeTypes;
  /** If specified, filter to runnables with matching tags */
  include_tags?: ChatStreamEventsRequestIncludeTags;
  /** If specified, exclude runnables with matching names */
  exclude_names?: ChatStreamEventsRequestExcludeNames;
  /** If specified, exclude runnables with matching types */
  exclude_types?: ChatStreamEventsRequestExcludeTypes;
  /** If specified, exclude runnables with matching tags */
  exclude_tags?: ChatStreamEventsRequestExcludeTags;
  kwargs?: ChatStreamEventsRequestKwargs;
}

/**
 * If specified, filter to runnables with matching names
 */
export type ChatStreamLogRequestIncludeNames = string[] | null;

/**
 * If specified, filter to runnables with matching types
 */
export type ChatStreamLogRequestIncludeTypes = string[] | null;

/**
 * If specified, filter to runnables with matching tags
 */
export type ChatStreamLogRequestIncludeTags = string[] | null;

/**
 * If specified, exclude runnables with matching names
 */
export type ChatStreamLogRequestExcludeNames = string[] | null;

/**
 * If specified, exclude runnables with matching types
 */
export type ChatStreamLogRequestExcludeTypes = string[] | null;

/**
 * If specified, exclude runnables with matching tags
 */
export type ChatStreamLogRequestExcludeTags = string[] | null;

export type ChatStreamLogRequestKwargs = { [key: string]: unknown };

export interface ChatStreamLogRequest {
  input: ChatOpenAIInput;
  config?: ChatChatOpenAIConfig;
  /** If specified, filter to runnables with matching names */
  include_names?: ChatStreamLogRequestIncludeNames;
  /** If specified, filter to runnables with matching types */
  include_types?: ChatStreamLogRequestIncludeTypes;
  /** If specified, filter to runnables with matching tags */
  include_tags?: ChatStreamLogRequestIncludeTags;
  /** If specified, exclude runnables with matching names */
  exclude_names?: ChatStreamLogRequestExcludeNames;
  /** If specified, exclude runnables with matching types */
  exclude_types?: ChatStreamLogRequestExcludeTypes;
  /** If specified, exclude runnables with matching tags */
  exclude_tags?: ChatStreamLogRequestExcludeTags;
  kwargs?: ChatStreamLogRequestKwargs;
}

/**
 * Keyword arguments to the runnable. Currently ignored.
 */
export type ChatStreamRequestKwargs = { [key: string]: unknown };

export interface ChatStreamRequest {
  /** The input to the runnable. */
  input: ChatOpenAIInput;
  /** Subset of RunnableConfig object in LangChain. Useful for passing information like tags, metadata etc. */
  config?: ChatChatOpenAIConfig;
  /** Keyword arguments to the runnable. Currently ignored. */
  kwargs?: ChatStreamRequestKwargs;
}

export type ChatInvokeChatInvokePostParams = {
config_hash?: string;
};

export type ChatBatchChatBatchPostParams = {
config_hash?: string;
};

export type ChatStreamChatStreamPostParams = {
config_hash?: string;
};

export type ChatStreamLogChatStreamLogPostParams = {
config_hash?: string;
};

export type ChatStreamEventsChatStreamEventsPostParams = {
config_hash?: string;
};





/**
 * @summary Root
 */
export const rootGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getRootGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown


export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Health Check
 */
export const healthCheckHealthGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/health`, method: 'GET', signal
    },
      );
    }
  

export const getHealthCheckHealthGetQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getHealthCheckHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) => healthCheckHealthGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = unknown


export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckHealthGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Return the input schema.
 * @summary Chat Input Schema
 */
export const chatInputSchemaChatInputSchemaGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/input_schema`, method: 'GET', signal
    },
      );
    }
  

export const getChatInputSchemaChatInputSchemaGetQueryKey = () => {
    return [`/chat/input_schema`] as const;
    }

    
export const getChatInputSchemaChatInputSchemaGetQueryOptions = <TData = Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getChatInputSchemaChatInputSchemaGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>> = ({ signal }) => chatInputSchemaChatInputSchemaGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ChatInputSchemaChatInputSchemaGetQueryResult = NonNullable<Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>>
export type ChatInputSchemaChatInputSchemaGetQueryError = unknown


export function useChatInputSchemaChatInputSchemaGet<TData = Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatInputSchemaChatInputSchemaGet<TData = Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatInputSchemaChatInputSchemaGet<TData = Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Chat Input Schema
 */

export function useChatInputSchemaChatInputSchemaGet<TData = Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaChatInputSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getChatInputSchemaChatInputSchemaGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Return the input schema.
 * @summary Chat Input Schema With Config
 */
export const chatInputSchemaWithConfigChatCConfigHashInputSchemaGet = (
    configHash: string,
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/c/${configHash}/input_schema`, method: 'GET', signal
    },
      );
    }
  

export const getChatInputSchemaWithConfigChatCConfigHashInputSchemaGetQueryKey = (configHash: string,) => {
    return [`/chat/c/${configHash}/input_schema`] as const;
    }

    
export const getChatInputSchemaWithConfigChatCConfigHashInputSchemaGetQueryOptions = <TData = Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError = HTTPValidationError>(configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getChatInputSchemaWithConfigChatCConfigHashInputSchemaGetQueryKey(configHash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>> = ({ signal }) => chatInputSchemaWithConfigChatCConfigHashInputSchemaGet(configHash, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(configHash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ChatInputSchemaWithConfigChatCConfigHashInputSchemaGetQueryResult = NonNullable<Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>>
export type ChatInputSchemaWithConfigChatCConfigHashInputSchemaGetQueryError = HTTPValidationError


export function useChatInputSchemaWithConfigChatCConfigHashInputSchemaGet<TData = Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatInputSchemaWithConfigChatCConfigHashInputSchemaGet<TData = Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatInputSchemaWithConfigChatCConfigHashInputSchemaGet<TData = Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Chat Input Schema With Config
 */

export function useChatInputSchemaWithConfigChatCConfigHashInputSchemaGet<TData = Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatInputSchemaWithConfigChatCConfigHashInputSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getChatInputSchemaWithConfigChatCConfigHashInputSchemaGetQueryOptions(configHash,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Return the output schema.
 * @summary Chat Output Schema
 */
export const chatOutputSchemaChatOutputSchemaGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/output_schema`, method: 'GET', signal
    },
      );
    }
  

export const getChatOutputSchemaChatOutputSchemaGetQueryKey = () => {
    return [`/chat/output_schema`] as const;
    }

    
export const getChatOutputSchemaChatOutputSchemaGetQueryOptions = <TData = Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getChatOutputSchemaChatOutputSchemaGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>> = ({ signal }) => chatOutputSchemaChatOutputSchemaGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ChatOutputSchemaChatOutputSchemaGetQueryResult = NonNullable<Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>>
export type ChatOutputSchemaChatOutputSchemaGetQueryError = unknown


export function useChatOutputSchemaChatOutputSchemaGet<TData = Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatOutputSchemaChatOutputSchemaGet<TData = Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatOutputSchemaChatOutputSchemaGet<TData = Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Chat Output Schema
 */

export function useChatOutputSchemaChatOutputSchemaGet<TData = Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaChatOutputSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getChatOutputSchemaChatOutputSchemaGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Return the output schema.
 * @summary Chat Output Schema With Config
 */
export const chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet = (
    configHash: string,
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/c/${configHash}/output_schema`, method: 'GET', signal
    },
      );
    }
  

export const getChatOutputSchemaWithConfigChatCConfigHashOutputSchemaGetQueryKey = (configHash: string,) => {
    return [`/chat/c/${configHash}/output_schema`] as const;
    }

    
export const getChatOutputSchemaWithConfigChatCConfigHashOutputSchemaGetQueryOptions = <TData = Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError = HTTPValidationError>(configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getChatOutputSchemaWithConfigChatCConfigHashOutputSchemaGetQueryKey(configHash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>> = ({ signal }) => chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet(configHash, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(configHash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ChatOutputSchemaWithConfigChatCConfigHashOutputSchemaGetQueryResult = NonNullable<Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>>
export type ChatOutputSchemaWithConfigChatCConfigHashOutputSchemaGetQueryError = HTTPValidationError


export function useChatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet<TData = Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet<TData = Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet<TData = Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Chat Output Schema With Config
 */

export function useChatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet<TData = Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatOutputSchemaWithConfigChatCConfigHashOutputSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getChatOutputSchemaWithConfigChatCConfigHashOutputSchemaGetQueryOptions(configHash,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Return the config schema.
 * @summary Chat Config Schema
 */
export const chatConfigSchemaChatConfigSchemaGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/config_schema`, method: 'GET', signal
    },
      );
    }
  

export const getChatConfigSchemaChatConfigSchemaGetQueryKey = () => {
    return [`/chat/config_schema`] as const;
    }

    
export const getChatConfigSchemaChatConfigSchemaGetQueryOptions = <TData = Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getChatConfigSchemaChatConfigSchemaGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>> = ({ signal }) => chatConfigSchemaChatConfigSchemaGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ChatConfigSchemaChatConfigSchemaGetQueryResult = NonNullable<Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>>
export type ChatConfigSchemaChatConfigSchemaGetQueryError = unknown


export function useChatConfigSchemaChatConfigSchemaGet<TData = Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatConfigSchemaChatConfigSchemaGet<TData = Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatConfigSchemaChatConfigSchemaGet<TData = Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Chat Config Schema
 */

export function useChatConfigSchemaChatConfigSchemaGet<TData = Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaChatConfigSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getChatConfigSchemaChatConfigSchemaGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Return the config schema.
 * @summary Chat Config Schema With Config
 */
export const chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet = (
    configHash: string,
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/c/${configHash}/config_schema`, method: 'GET', signal
    },
      );
    }
  

export const getChatConfigSchemaWithConfigChatCConfigHashConfigSchemaGetQueryKey = (configHash: string,) => {
    return [`/chat/c/${configHash}/config_schema`] as const;
    }

    
export const getChatConfigSchemaWithConfigChatCConfigHashConfigSchemaGetQueryOptions = <TData = Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError = HTTPValidationError>(configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getChatConfigSchemaWithConfigChatCConfigHashConfigSchemaGetQueryKey(configHash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>> = ({ signal }) => chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet(configHash, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(configHash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ChatConfigSchemaWithConfigChatCConfigHashConfigSchemaGetQueryResult = NonNullable<Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>>
export type ChatConfigSchemaWithConfigChatCConfigHashConfigSchemaGetQueryError = HTTPValidationError


export function useChatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet<TData = Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet<TData = Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>,
          TError,
          Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useChatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet<TData = Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Chat Config Schema With Config
 */

export function useChatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet<TData = Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError = HTTPValidationError>(
 configHash: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof chatConfigSchemaWithConfigChatCConfigHashConfigSchemaGet>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getChatConfigSchemaWithConfigChatCConfigHashConfigSchemaGetQueryOptions(configHash,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Send feedback on an individual run to langsmith.
 * @summary Create Feedback From Token
 */
export const createFeedbackFromTokenChatTokenFeedbackPost = (
    feedbackCreateRequestTokenBased: FeedbackCreateRequestTokenBased,
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/token_feedback`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: feedbackCreateRequestTokenBased, signal
    },
      );
    }
  


export const getCreateFeedbackFromTokenChatTokenFeedbackPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFeedbackFromTokenChatTokenFeedbackPost>>, TError,{data: FeedbackCreateRequestTokenBased}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createFeedbackFromTokenChatTokenFeedbackPost>>, TError,{data: FeedbackCreateRequestTokenBased}, TContext> => {
    
const mutationKey = ['createFeedbackFromTokenChatTokenFeedbackPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFeedbackFromTokenChatTokenFeedbackPost>>, {data: FeedbackCreateRequestTokenBased}> = (props) => {
          const {data} = props ?? {};

          return  createFeedbackFromTokenChatTokenFeedbackPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateFeedbackFromTokenChatTokenFeedbackPostMutationResult = NonNullable<Awaited<ReturnType<typeof createFeedbackFromTokenChatTokenFeedbackPost>>>
    export type CreateFeedbackFromTokenChatTokenFeedbackPostMutationBody = FeedbackCreateRequestTokenBased
    export type CreateFeedbackFromTokenChatTokenFeedbackPostMutationError = HTTPValidationError

    /**
 * @summary Create Feedback From Token
 */
export const useCreateFeedbackFromTokenChatTokenFeedbackPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFeedbackFromTokenChatTokenFeedbackPost>>, TError,{data: FeedbackCreateRequestTokenBased}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createFeedbackFromTokenChatTokenFeedbackPost>>,
        TError,
        {data: FeedbackCreateRequestTokenBased},
        TContext
      > => {

      const mutationOptions = getCreateFeedbackFromTokenChatTokenFeedbackPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Invoke the runnable with the given input and config.
 * @summary Chat Invoke
 */
export const chatInvokeChatInvokePost = (
    chatInvokeRequest: ChatInvokeRequest,
    params?: ChatInvokeChatInvokePostParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ChatInvokeResponse>(
      {url: `/chat/invoke`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chatInvokeRequest,
        params, signal
    },
      );
    }
  


export const getChatInvokeChatInvokePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatInvokeChatInvokePost>>, TError,{data: ChatInvokeRequest;params?: ChatInvokeChatInvokePostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatInvokeChatInvokePost>>, TError,{data: ChatInvokeRequest;params?: ChatInvokeChatInvokePostParams}, TContext> => {
    
const mutationKey = ['chatInvokeChatInvokePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatInvokeChatInvokePost>>, {data: ChatInvokeRequest;params?: ChatInvokeChatInvokePostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  chatInvokeChatInvokePost(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatInvokeChatInvokePostMutationResult = NonNullable<Awaited<ReturnType<typeof chatInvokeChatInvokePost>>>
    export type ChatInvokeChatInvokePostMutationBody = ChatInvokeRequest
    export type ChatInvokeChatInvokePostMutationError = HTTPValidationError

    /**
 * @summary Chat Invoke
 */
export const useChatInvokeChatInvokePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatInvokeChatInvokePost>>, TError,{data: ChatInvokeRequest;params?: ChatInvokeChatInvokePostParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof chatInvokeChatInvokePost>>,
        TError,
        {data: ChatInvokeRequest;params?: ChatInvokeChatInvokePostParams},
        TContext
      > => {

      const mutationOptions = getChatInvokeChatInvokePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint is to be used with share links generated by the LangServe playground. The hash is an LZString compressed JSON string. For regular use cases, use the /invoke endpoint without the `c/{config_hash}` path parameter.
 * @summary Chat Invoke With Config
 */
export const chatInvokeWithConfigChatCConfigHashInvokePost = (
    configHash: string,
    chatInvokeRequest: ChatInvokeRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ChatInvokeResponse>(
      {url: `/chat/c/${configHash}/invoke`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chatInvokeRequest, signal
    },
      );
    }
  


export const getChatInvokeWithConfigChatCConfigHashInvokePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatInvokeWithConfigChatCConfigHashInvokePost>>, TError,{configHash: string;data: ChatInvokeRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatInvokeWithConfigChatCConfigHashInvokePost>>, TError,{configHash: string;data: ChatInvokeRequest}, TContext> => {
    
const mutationKey = ['chatInvokeWithConfigChatCConfigHashInvokePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatInvokeWithConfigChatCConfigHashInvokePost>>, {configHash: string;data: ChatInvokeRequest}> = (props) => {
          const {configHash,data} = props ?? {};

          return  chatInvokeWithConfigChatCConfigHashInvokePost(configHash,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatInvokeWithConfigChatCConfigHashInvokePostMutationResult = NonNullable<Awaited<ReturnType<typeof chatInvokeWithConfigChatCConfigHashInvokePost>>>
    export type ChatInvokeWithConfigChatCConfigHashInvokePostMutationBody = ChatInvokeRequest
    export type ChatInvokeWithConfigChatCConfigHashInvokePostMutationError = HTTPValidationError

    /**
 * @summary Chat Invoke With Config
 */
export const useChatInvokeWithConfigChatCConfigHashInvokePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatInvokeWithConfigChatCConfigHashInvokePost>>, TError,{configHash: string;data: ChatInvokeRequest}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof chatInvokeWithConfigChatCConfigHashInvokePost>>,
        TError,
        {configHash: string;data: ChatInvokeRequest},
        TContext
      > => {

      const mutationOptions = getChatInvokeWithConfigChatCConfigHashInvokePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Batch invoke the runnable with the given inputs and config.
 * @summary Chat Batch
 */
export const chatBatchChatBatchPost = (
    chatBatchRequest: ChatBatchRequest,
    params?: ChatBatchChatBatchPostParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ChatBatchResponse>(
      {url: `/chat/batch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chatBatchRequest,
        params, signal
    },
      );
    }
  


export const getChatBatchChatBatchPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatBatchChatBatchPost>>, TError,{data: ChatBatchRequest;params?: ChatBatchChatBatchPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatBatchChatBatchPost>>, TError,{data: ChatBatchRequest;params?: ChatBatchChatBatchPostParams}, TContext> => {
    
const mutationKey = ['chatBatchChatBatchPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatBatchChatBatchPost>>, {data: ChatBatchRequest;params?: ChatBatchChatBatchPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  chatBatchChatBatchPost(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatBatchChatBatchPostMutationResult = NonNullable<Awaited<ReturnType<typeof chatBatchChatBatchPost>>>
    export type ChatBatchChatBatchPostMutationBody = ChatBatchRequest
    export type ChatBatchChatBatchPostMutationError = HTTPValidationError

    /**
 * @summary Chat Batch
 */
export const useChatBatchChatBatchPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatBatchChatBatchPost>>, TError,{data: ChatBatchRequest;params?: ChatBatchChatBatchPostParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof chatBatchChatBatchPost>>,
        TError,
        {data: ChatBatchRequest;params?: ChatBatchChatBatchPostParams},
        TContext
      > => {

      const mutationOptions = getChatBatchChatBatchPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint is to be used with share links generated by the LangServe playground. The hash is an LZString compressed JSON string. For regular use cases, use the /batch endpoint without the `c/{config_hash}` path parameter.
 * @summary Chat Batch With Config
 */
export const chatBatchWithConfigChatCConfigHashBatchPost = (
    configHash: string,
    chatBatchRequest: ChatBatchRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxios<ChatBatchResponse>(
      {url: `/chat/c/${configHash}/batch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chatBatchRequest, signal
    },
      );
    }
  


export const getChatBatchWithConfigChatCConfigHashBatchPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatBatchWithConfigChatCConfigHashBatchPost>>, TError,{configHash: string;data: ChatBatchRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatBatchWithConfigChatCConfigHashBatchPost>>, TError,{configHash: string;data: ChatBatchRequest}, TContext> => {
    
const mutationKey = ['chatBatchWithConfigChatCConfigHashBatchPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatBatchWithConfigChatCConfigHashBatchPost>>, {configHash: string;data: ChatBatchRequest}> = (props) => {
          const {configHash,data} = props ?? {};

          return  chatBatchWithConfigChatCConfigHashBatchPost(configHash,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatBatchWithConfigChatCConfigHashBatchPostMutationResult = NonNullable<Awaited<ReturnType<typeof chatBatchWithConfigChatCConfigHashBatchPost>>>
    export type ChatBatchWithConfigChatCConfigHashBatchPostMutationBody = ChatBatchRequest
    export type ChatBatchWithConfigChatCConfigHashBatchPostMutationError = HTTPValidationError

    /**
 * @summary Chat Batch With Config
 */
export const useChatBatchWithConfigChatCConfigHashBatchPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatBatchWithConfigChatCConfigHashBatchPost>>, TError,{configHash: string;data: ChatBatchRequest}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof chatBatchWithConfigChatCConfigHashBatchPost>>,
        TError,
        {configHash: string;data: ChatBatchRequest},
        TContext
      > => {

      const mutationOptions = getChatBatchWithConfigChatCConfigHashBatchPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows to stream the output of the runnable. The endpoint uses a server sent event stream to stream the output. https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events
 * @summary Chat Stream
 */
export const chatStreamChatStreamPost = (
    chatStreamRequest: ChatStreamRequest,
    params?: ChatStreamChatStreamPostParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/stream`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chatStreamRequest,
        params, signal
    },
      );
    }
  


export const getChatStreamChatStreamPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamChatStreamPost>>, TError,{data: ChatStreamRequest;params?: ChatStreamChatStreamPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatStreamChatStreamPost>>, TError,{data: ChatStreamRequest;params?: ChatStreamChatStreamPostParams}, TContext> => {
    
const mutationKey = ['chatStreamChatStreamPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatStreamChatStreamPost>>, {data: ChatStreamRequest;params?: ChatStreamChatStreamPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  chatStreamChatStreamPost(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatStreamChatStreamPostMutationResult = NonNullable<Awaited<ReturnType<typeof chatStreamChatStreamPost>>>
    export type ChatStreamChatStreamPostMutationBody = ChatStreamRequest
    export type ChatStreamChatStreamPostMutationError = HTTPValidationError

    /**
 * @summary Chat Stream
 */
export const useChatStreamChatStreamPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamChatStreamPost>>, TError,{data: ChatStreamRequest;params?: ChatStreamChatStreamPostParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof chatStreamChatStreamPost>>,
        TError,
        {data: ChatStreamRequest;params?: ChatStreamChatStreamPostParams},
        TContext
      > => {

      const mutationOptions = getChatStreamChatStreamPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint is to be used with share links generated by the LangServe playground. The hash is an LZString compressed JSON string. For regular use cases, use the /stream endpoint without the `c/{config_hash}` path parameter.
 * @summary Chat Stream With Config
 */
export const chatStreamWithConfigChatCConfigHashStreamPost = (
    configHash: string,
    chatStreamRequest: ChatStreamRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/c/${configHash}/stream`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chatStreamRequest, signal
    },
      );
    }
  


export const getChatStreamWithConfigChatCConfigHashStreamPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamWithConfigChatCConfigHashStreamPost>>, TError,{configHash: string;data: ChatStreamRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatStreamWithConfigChatCConfigHashStreamPost>>, TError,{configHash: string;data: ChatStreamRequest}, TContext> => {
    
const mutationKey = ['chatStreamWithConfigChatCConfigHashStreamPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatStreamWithConfigChatCConfigHashStreamPost>>, {configHash: string;data: ChatStreamRequest}> = (props) => {
          const {configHash,data} = props ?? {};

          return  chatStreamWithConfigChatCConfigHashStreamPost(configHash,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatStreamWithConfigChatCConfigHashStreamPostMutationResult = NonNullable<Awaited<ReturnType<typeof chatStreamWithConfigChatCConfigHashStreamPost>>>
    export type ChatStreamWithConfigChatCConfigHashStreamPostMutationBody = ChatStreamRequest
    export type ChatStreamWithConfigChatCConfigHashStreamPostMutationError = HTTPValidationError

    /**
 * @summary Chat Stream With Config
 */
export const useChatStreamWithConfigChatCConfigHashStreamPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamWithConfigChatCConfigHashStreamPost>>, TError,{configHash: string;data: ChatStreamRequest}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof chatStreamWithConfigChatCConfigHashStreamPost>>,
        TError,
        {configHash: string;data: ChatStreamRequest},
        TContext
      > => {

      const mutationOptions = getChatStreamWithConfigChatCConfigHashStreamPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Invoke the runnable stream_log the output.

This endpoint allows to stream the output of the runnable, including
the output of all intermediate steps.

The endpoint uses a server sent event stream to stream the output.

https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events

Important: Set the "text/event-stream" media type for request headers if
           not using an existing SDK.

This endpoint uses two different types of events:

* data - for streaming the output of the runnable

    {
        "event": "data",
        "data": {
        ...
        }
    }

* error - for signaling an error in the stream, also ends the stream.

{
    "event": "error",
    "data": {
        "status_code": 500,
        "message": "Internal Server Error"
    }
}

* end - for signaling the end of the stream.

    This helps the client to know when to stop listening for events and
    know that the streaming has ended successfully.

    {
        "event": "end",
    }
 * @summary Chat Stream Log
 */
export const chatStreamLogChatStreamLogPost = (
    chatStreamLogRequest: ChatStreamLogRequest,
    params?: ChatStreamLogChatStreamLogPostParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/stream_log`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chatStreamLogRequest,
        params, signal
    },
      );
    }
  


export const getChatStreamLogChatStreamLogPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamLogChatStreamLogPost>>, TError,{data: ChatStreamLogRequest;params?: ChatStreamLogChatStreamLogPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatStreamLogChatStreamLogPost>>, TError,{data: ChatStreamLogRequest;params?: ChatStreamLogChatStreamLogPostParams}, TContext> => {
    
const mutationKey = ['chatStreamLogChatStreamLogPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatStreamLogChatStreamLogPost>>, {data: ChatStreamLogRequest;params?: ChatStreamLogChatStreamLogPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  chatStreamLogChatStreamLogPost(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatStreamLogChatStreamLogPostMutationResult = NonNullable<Awaited<ReturnType<typeof chatStreamLogChatStreamLogPost>>>
    export type ChatStreamLogChatStreamLogPostMutationBody = ChatStreamLogRequest
    export type ChatStreamLogChatStreamLogPostMutationError = HTTPValidationError

    /**
 * @summary Chat Stream Log
 */
export const useChatStreamLogChatStreamLogPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamLogChatStreamLogPost>>, TError,{data: ChatStreamLogRequest;params?: ChatStreamLogChatStreamLogPostParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof chatStreamLogChatStreamLogPost>>,
        TError,
        {data: ChatStreamLogRequest;params?: ChatStreamLogChatStreamLogPostParams},
        TContext
      > => {

      const mutationOptions = getChatStreamLogChatStreamLogPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint is to be used with share links generated by the LangServe playground. The hash is an LZString compressed JSON string. For regular use cases, use the /stream_log endpoint without the `c/{config_hash}` path parameter.
 * @summary Chat Stream Log With Config
 */
export const chatStreamLogWithConfigChatCConfigHashStreamLogPost = (
    configHash: string,
    chatStreamLogRequest: ChatStreamLogRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/c/${configHash}/stream_log`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chatStreamLogRequest, signal
    },
      );
    }
  


export const getChatStreamLogWithConfigChatCConfigHashStreamLogPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamLogWithConfigChatCConfigHashStreamLogPost>>, TError,{configHash: string;data: ChatStreamLogRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatStreamLogWithConfigChatCConfigHashStreamLogPost>>, TError,{configHash: string;data: ChatStreamLogRequest}, TContext> => {
    
const mutationKey = ['chatStreamLogWithConfigChatCConfigHashStreamLogPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatStreamLogWithConfigChatCConfigHashStreamLogPost>>, {configHash: string;data: ChatStreamLogRequest}> = (props) => {
          const {configHash,data} = props ?? {};

          return  chatStreamLogWithConfigChatCConfigHashStreamLogPost(configHash,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatStreamLogWithConfigChatCConfigHashStreamLogPostMutationResult = NonNullable<Awaited<ReturnType<typeof chatStreamLogWithConfigChatCConfigHashStreamLogPost>>>
    export type ChatStreamLogWithConfigChatCConfigHashStreamLogPostMutationBody = ChatStreamLogRequest
    export type ChatStreamLogWithConfigChatCConfigHashStreamLogPostMutationError = HTTPValidationError

    /**
 * @summary Chat Stream Log With Config
 */
export const useChatStreamLogWithConfigChatCConfigHashStreamLogPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamLogWithConfigChatCConfigHashStreamLogPost>>, TError,{configHash: string;data: ChatStreamLogRequest}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof chatStreamLogWithConfigChatCConfigHashStreamLogPost>>,
        TError,
        {configHash: string;data: ChatStreamLogRequest},
        TContext
      > => {

      const mutationOptions = getChatStreamLogWithConfigChatCConfigHashStreamLogPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Stream events from the given runnable.

This endpoint allows to stream events from the runnable, including
events from all intermediate steps.

**Attention**

    This is a new endpoint that only works for langchain-core >= 0.1.14.

    It belongs to a Beta API that may change in the future.

**Important**
    Specify filters to the events you want to receive by setting
    the appropriate filters in the request body.

    This will help avoid sending too much data over the network.

    It will also prevent serialization issues with
    any unsupported types since it won't need to serialize events
    that aren't transmitted.

The endpoint uses a server sent event stream to stream the output.

https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events

The encoding of events follows the following format:

* data - for streaming the output of the runnable

    {
        "event": "data",
        "data": {
        ...
        }
    }

* error - for signaling an error in the stream, also ends the stream.

{
    "event": "error",
    "data": {
        "status_code": 500,
        "message": "Internal Server Error"
    }
}

* end - for signaling the end of the stream.

    This helps the client to know when to stop listening for events and
    know that the streaming has ended successfully.

    {
        "event": "end",
    }

`data` for the `data` event is a JSON object that corresponds
to a serialized representation of a StreamEvent.

See LangChain documentation for more information about astream_events.
 * @summary Chat Stream Events
 */
export const chatStreamEventsChatStreamEventsPost = (
    chatStreamEventsRequest: ChatStreamEventsRequest,
    params?: ChatStreamEventsChatStreamEventsPostParams,
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/stream_events`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chatStreamEventsRequest,
        params, signal
    },
      );
    }
  


export const getChatStreamEventsChatStreamEventsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamEventsChatStreamEventsPost>>, TError,{data: ChatStreamEventsRequest;params?: ChatStreamEventsChatStreamEventsPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatStreamEventsChatStreamEventsPost>>, TError,{data: ChatStreamEventsRequest;params?: ChatStreamEventsChatStreamEventsPostParams}, TContext> => {
    
const mutationKey = ['chatStreamEventsChatStreamEventsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatStreamEventsChatStreamEventsPost>>, {data: ChatStreamEventsRequest;params?: ChatStreamEventsChatStreamEventsPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  chatStreamEventsChatStreamEventsPost(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatStreamEventsChatStreamEventsPostMutationResult = NonNullable<Awaited<ReturnType<typeof chatStreamEventsChatStreamEventsPost>>>
    export type ChatStreamEventsChatStreamEventsPostMutationBody = ChatStreamEventsRequest
    export type ChatStreamEventsChatStreamEventsPostMutationError = HTTPValidationError

    /**
 * @summary Chat Stream Events
 */
export const useChatStreamEventsChatStreamEventsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamEventsChatStreamEventsPost>>, TError,{data: ChatStreamEventsRequest;params?: ChatStreamEventsChatStreamEventsPostParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof chatStreamEventsChatStreamEventsPost>>,
        TError,
        {data: ChatStreamEventsRequest;params?: ChatStreamEventsChatStreamEventsPostParams},
        TContext
      > => {

      const mutationOptions = getChatStreamEventsChatStreamEventsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint is to be used with share links generated by the LangServe playground. The hash is an LZString compressed JSON string. For regular use cases, use the /stream_events endpoint without the `c/{config_hash}` path parameter.
 * @summary Chat Stream Events With Config
 */
export const chatStreamEventsWithConfigChatCConfigHashStreamEventsPost = (
    configHash: string,
    chatStreamEventsRequest: ChatStreamEventsRequest,
 signal?: AbortSignal
) => {
      
      
      return customAxios<unknown>(
      {url: `/chat/c/${configHash}/stream_events`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: chatStreamEventsRequest, signal
    },
      );
    }
  


export const getChatStreamEventsWithConfigChatCConfigHashStreamEventsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamEventsWithConfigChatCConfigHashStreamEventsPost>>, TError,{configHash: string;data: ChatStreamEventsRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof chatStreamEventsWithConfigChatCConfigHashStreamEventsPost>>, TError,{configHash: string;data: ChatStreamEventsRequest}, TContext> => {
    
const mutationKey = ['chatStreamEventsWithConfigChatCConfigHashStreamEventsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof chatStreamEventsWithConfigChatCConfigHashStreamEventsPost>>, {configHash: string;data: ChatStreamEventsRequest}> = (props) => {
          const {configHash,data} = props ?? {};

          return  chatStreamEventsWithConfigChatCConfigHashStreamEventsPost(configHash,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChatStreamEventsWithConfigChatCConfigHashStreamEventsPostMutationResult = NonNullable<Awaited<ReturnType<typeof chatStreamEventsWithConfigChatCConfigHashStreamEventsPost>>>
    export type ChatStreamEventsWithConfigChatCConfigHashStreamEventsPostMutationBody = ChatStreamEventsRequest
    export type ChatStreamEventsWithConfigChatCConfigHashStreamEventsPostMutationError = HTTPValidationError

    /**
 * @summary Chat Stream Events With Config
 */
export const useChatStreamEventsWithConfigChatCConfigHashStreamEventsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof chatStreamEventsWithConfigChatCConfigHashStreamEventsPost>>, TError,{configHash: string;data: ChatStreamEventsRequest}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof chatStreamEventsWithConfigChatCConfigHashStreamEventsPost>>,
        TError,
        {configHash: string;data: ChatStreamEventsRequest},
        TContext
      > => {

      const mutationOptions = getChatStreamEventsWithConfigChatCConfigHashStreamEventsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
